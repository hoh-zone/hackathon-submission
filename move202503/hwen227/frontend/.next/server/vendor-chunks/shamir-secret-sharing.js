"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/shamir-secret-sharing";
exports.ids = ["vendor-chunks/shamir-secret-sharing"];
exports.modules = {

/***/ "(ssr)/./node_modules/shamir-secret-sharing/esm/csprng.node.js":
/*!***************************************************************!*\
  !*** ./node_modules/shamir-secret-sharing/esm/csprng.node.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n\nfunction getRandomBytes(numBytes) {\n    return new Uint8Array((0,node_crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(numBytes).buffer);\n}\n//# sourceMappingURL=csprng.node.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2hhbWlyLXNlY3JldC1zaGFyaW5nL2VzbS9jc3Bybmcubm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUNuQztBQUNQLDBCQUEwQix3REFBVztBQUNyQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2hhbWlyLXNlY3JldC1zaGFyaW5nL2VzbS9jc3Bybmcubm9kZS5qcz8wOGMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzKG51bUJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJhbmRvbUJ5dGVzKG51bUJ5dGVzKS5idWZmZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Nwcm5nLm5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/shamir-secret-sharing/esm/csprng.node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/shamir-secret-sharing/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/shamir-secret-sharing/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   split: () => (/* binding */ split)\n/* harmony export */ });\n/* harmony import */ var shamir_secret_sharing_csprng__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shamir-secret-sharing/csprng */ \"(ssr)/./node_modules/shamir-secret-sharing/esm/csprng.node.js\");\n\n// The Polynomial used is: x⁸ + x⁴ + x³ + x + 1\n//\n// Lookup tables pulled from:\n//\n//     * https://github.com/hashicorp/vault/blob/9d46671659cbfe7bbd3e78d1073dfb22936a4437/shamir/tables.go\n//     * http://www.samiam.org/galois.html\n//\n// 0xe5 (229) is used as the generator.\n// Provides log(X)/log(g) at each index X.\nconst LOG_TABLE = new Uint8Array([\n    0x00, 0xff, 0xc8, 0x08, 0x91, 0x10, 0xd0, 0x36, 0x5a, 0x3e, 0xd8, 0x43, 0x99, 0x77, 0xfe, 0x18,\n    0x23, 0x20, 0x07, 0x70, 0xa1, 0x6c, 0x0c, 0x7f, 0x62, 0x8b, 0x40, 0x46, 0xc7, 0x4b, 0xe0, 0x0e,\n    0xeb, 0x16, 0xe8, 0xad, 0xcf, 0xcd, 0x39, 0x53, 0x6a, 0x27, 0x35, 0x93, 0xd4, 0x4e, 0x48, 0xc3,\n    0x2b, 0x79, 0x54, 0x28, 0x09, 0x78, 0x0f, 0x21, 0x90, 0x87, 0x14, 0x2a, 0xa9, 0x9c, 0xd6, 0x74,\n    0xb4, 0x7c, 0xde, 0xed, 0xb1, 0x86, 0x76, 0xa4, 0x98, 0xe2, 0x96, 0x8f, 0x02, 0x32, 0x1c, 0xc1,\n    0x33, 0xee, 0xef, 0x81, 0xfd, 0x30, 0x5c, 0x13, 0x9d, 0x29, 0x17, 0xc4, 0x11, 0x44, 0x8c, 0x80,\n    0xf3, 0x73, 0x42, 0x1e, 0x1d, 0xb5, 0xf0, 0x12, 0xd1, 0x5b, 0x41, 0xa2, 0xd7, 0x2c, 0xe9, 0xd5,\n    0x59, 0xcb, 0x50, 0xa8, 0xdc, 0xfc, 0xf2, 0x56, 0x72, 0xa6, 0x65, 0x2f, 0x9f, 0x9b, 0x3d, 0xba,\n    0x7d, 0xc2, 0x45, 0x82, 0xa7, 0x57, 0xb6, 0xa3, 0x7a, 0x75, 0x4f, 0xae, 0x3f, 0x37, 0x6d, 0x47,\n    0x61, 0xbe, 0xab, 0xd3, 0x5f, 0xb0, 0x58, 0xaf, 0xca, 0x5e, 0xfa, 0x85, 0xe4, 0x4d, 0x8a, 0x05,\n    0xfb, 0x60, 0xb7, 0x7b, 0xb8, 0x26, 0x4a, 0x67, 0xc6, 0x1a, 0xf8, 0x69, 0x25, 0xb3, 0xdb, 0xbd,\n    0x66, 0xdd, 0xf1, 0xd2, 0xdf, 0x03, 0x8d, 0x34, 0xd9, 0x92, 0x0d, 0x63, 0x55, 0xaa, 0x49, 0xec,\n    0xbc, 0x95, 0x3c, 0x84, 0x0b, 0xf5, 0xe6, 0xe7, 0xe5, 0xac, 0x7e, 0x6e, 0xb9, 0xf9, 0xda, 0x8e,\n    0x9a, 0xc9, 0x24, 0xe1, 0x0a, 0x15, 0x6b, 0x3a, 0xa0, 0x51, 0xf4, 0xea, 0xb2, 0x97, 0x9e, 0x5d,\n    0x22, 0x88, 0x94, 0xce, 0x19, 0x01, 0x71, 0x4c, 0xa5, 0xe3, 0xc5, 0x31, 0xbb, 0xcc, 0x1f, 0x2d,\n    0x3b, 0x52, 0x6f, 0xf6, 0x2e, 0x89, 0xf7, 0xc0, 0x68, 0x1b, 0x64, 0x04, 0x06, 0xbf, 0x83, 0x38,\n]);\n// Provides the exponentiation value at each index X.\nconst EXP_TABLE = new Uint8Array([\n    0x01, 0xe5, 0x4c, 0xb5, 0xfb, 0x9f, 0xfc, 0x12, 0x03, 0x34, 0xd4, 0xc4, 0x16, 0xba, 0x1f, 0x36,\n    0x05, 0x5c, 0x67, 0x57, 0x3a, 0xd5, 0x21, 0x5a, 0x0f, 0xe4, 0xa9, 0xf9, 0x4e, 0x64, 0x63, 0xee,\n    0x11, 0x37, 0xe0, 0x10, 0xd2, 0xac, 0xa5, 0x29, 0x33, 0x59, 0x3b, 0x30, 0x6d, 0xef, 0xf4, 0x7b,\n    0x55, 0xeb, 0x4d, 0x50, 0xb7, 0x2a, 0x07, 0x8d, 0xff, 0x26, 0xd7, 0xf0, 0xc2, 0x7e, 0x09, 0x8c,\n    0x1a, 0x6a, 0x62, 0x0b, 0x5d, 0x82, 0x1b, 0x8f, 0x2e, 0xbe, 0xa6, 0x1d, 0xe7, 0x9d, 0x2d, 0x8a,\n    0x72, 0xd9, 0xf1, 0x27, 0x32, 0xbc, 0x77, 0x85, 0x96, 0x70, 0x08, 0x69, 0x56, 0xdf, 0x99, 0x94,\n    0xa1, 0x90, 0x18, 0xbb, 0xfa, 0x7a, 0xb0, 0xa7, 0xf8, 0xab, 0x28, 0xd6, 0x15, 0x8e, 0xcb, 0xf2,\n    0x13, 0xe6, 0x78, 0x61, 0x3f, 0x89, 0x46, 0x0d, 0x35, 0x31, 0x88, 0xa3, 0x41, 0x80, 0xca, 0x17,\n    0x5f, 0x53, 0x83, 0xfe, 0xc3, 0x9b, 0x45, 0x39, 0xe1, 0xf5, 0x9e, 0x19, 0x5e, 0xb6, 0xcf, 0x4b,\n    0x38, 0x04, 0xb9, 0x2b, 0xe2, 0xc1, 0x4a, 0xdd, 0x48, 0x0c, 0xd0, 0x7d, 0x3d, 0x58, 0xde, 0x7c,\n    0xd8, 0x14, 0x6b, 0x87, 0x47, 0xe8, 0x79, 0x84, 0x73, 0x3c, 0xbd, 0x92, 0xc9, 0x23, 0x8b, 0x97,\n    0x95, 0x44, 0xdc, 0xad, 0x40, 0x65, 0x86, 0xa2, 0xa4, 0xcc, 0x7f, 0xec, 0xc0, 0xaf, 0x91, 0xfd,\n    0xf7, 0x4f, 0x81, 0x2f, 0x5b, 0xea, 0xa8, 0x1c, 0x02, 0xd1, 0x98, 0x71, 0xed, 0x25, 0xe3, 0x24,\n    0x06, 0x68, 0xb3, 0x93, 0x2c, 0x6f, 0x3e, 0x6c, 0x0a, 0xb8, 0xce, 0xae, 0x74, 0xb1, 0x42, 0xb4,\n    0x1e, 0xd3, 0x49, 0xe9, 0x9c, 0xc8, 0xc6, 0xc7, 0x22, 0x6e, 0xdb, 0x20, 0xbf, 0x43, 0x51, 0x52,\n    0x66, 0xb2, 0x76, 0x60, 0xda, 0xc5, 0xf3, 0xf6, 0xaa, 0xcd, 0x9a, 0xa0, 0x75, 0x54, 0x0e, 0x01,\n]);\n// Combines two numbers in GF(2^8).\n// This can be used for both addition and subtraction.\nfunction add(a, b) {\n    if (!Number.isInteger(a) || a < 0 || a > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    if (!Number.isInteger(b) || b < 0 || b > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    return a ^ b;\n}\n// Divides two numbers in GF(2^8).\nfunction div(a, b) {\n    if (!Number.isInteger(a) || a < 0 || a > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    if (!Number.isInteger(b) || b < 0 || b > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    // This should never happen\n    if (b === 0) {\n        throw new Error('cannot divide by zero');\n    }\n    const logA = LOG_TABLE[a];\n    const logB = LOG_TABLE[b];\n    const diff = (logA - logB + 255) % 255;\n    const result = EXP_TABLE[diff];\n    return a === 0 ? 0 : result;\n}\n// Multiplies two numbers in GF(2^8).\nfunction mult(a, b) {\n    if (!Number.isInteger(a) || a < 0 || a > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    if (!Number.isInteger(b) || b < 0 || b > 255) {\n        throw new RangeError('Number is out of Uint8 range');\n    }\n    const logA = LOG_TABLE[a];\n    const logB = LOG_TABLE[b];\n    const sum = (logA + logB) % 255;\n    const result = EXP_TABLE[sum];\n    return a === 0 || b === 0 ? 0 : result;\n}\n// Takes N sample points and returns the value at a given x using a lagrange interpolation.\nfunction interpolatePolynomial(xSamples, ySamples, x) {\n    if (xSamples.length !== ySamples.length) {\n        throw new Error('sample length mistmatch');\n    }\n    const limit = xSamples.length;\n    let basis = 0;\n    let result = 0;\n    for (let i = 0; i < limit; i++) {\n        basis = 1;\n        for (let j = 0; j < limit; ++j) {\n            if (i === j) {\n                continue;\n            }\n            const num = add(x, xSamples[j]);\n            const denom = add(xSamples[i], xSamples[j]);\n            const term = div(num, denom);\n            basis = mult(basis, term);\n        }\n        result = add(result, mult(ySamples[i], basis));\n    }\n    return result;\n}\n// Evaluates a polynomial with the given x using Horner's method.\nfunction evaluate(coefficients, x, degree) {\n    if (x === 0) {\n        throw new Error('cannot evaluate secret polynomial at zero');\n    }\n    let result = coefficients[degree];\n    for (let i = degree - 1; i >= 0; i--) {\n        const coefficient = coefficients[i];\n        result = add(mult(result, x), coefficient);\n    }\n    return result;\n}\nfunction getRandomByte() {\n    return (0,shamir_secret_sharing_csprng__WEBPACK_IMPORTED_MODULE_0__.getRandomBytes)(1)[0];\n}\nfunction getNonZeroRandomByte() {\n    while (true) {\n        const byte = getRandomByte();\n        if (byte > 0) {\n            return byte;\n        }\n    }\n}\n// Creates a pseudo-random set of coefficients for a polynomial.\nfunction newCoefficients(intercept, degree) {\n    const coefficients = new Uint8Array(degree + 1);\n    // The first byte is always the intercept\n    coefficients[0] = intercept;\n    for (let i = 1; i <= degree; i++) {\n        // degree is equal to t-1, where t is the threshold of required shares.\n        // The coefficient at t-1 cannot equal 0.\n        const coefficientTMinus1 = i === degree;\n        coefficients[i] = coefficientTMinus1 ? getNonZeroRandomByte() : getRandomByte();\n    }\n    return coefficients;\n}\n// Creates a set of values from [1, 256).\n// Returns a psuedo-random shuffling of the set.\nfunction newCoordinates() {\n    const coordinates = new Uint8Array(255);\n    for (let i = 0; i < 255; i++) {\n        coordinates[i] = i + 1;\n    }\n    // Pseudo-randomize the array of coordinates.\n    //\n    // This impl maps almost perfectly because both of the lists (coordinates and randomIndices)\n    // have a length of 255 and byte values are between 0 and 255 inclusive. The only value that\n    // does not map neatly here is if the random byte is 255, since that value used as an index\n    // would be out of bounds. Thus, for bytes whose value is 255, wrap around to 0.\n    const randomIndices = (0,shamir_secret_sharing_csprng__WEBPACK_IMPORTED_MODULE_0__.getRandomBytes)(255);\n    for (let i = 0; i < 255; i++) {\n        const j = randomIndices[i] % 255; // Make sure to handle the case where the byte is 255.\n        const temp = coordinates[i];\n        coordinates[i] = coordinates[j];\n        coordinates[j] = temp;\n    }\n    return coordinates;\n}\n// Helpers for declarative argument validation.\nconst AssertArgument = {\n    instanceOf(object, constructor, message) {\n        if (object.constructor !== constructor) {\n            throw new TypeError(message);\n        }\n    },\n    inRange(n, start, until, message) {\n        if (!(start < until && n >= start && n < until)) {\n            throw new RangeError(message);\n        }\n    },\n    greaterThanOrEqualTo(a, b, message) {\n        if (a < b) {\n            throw new Error(message);\n        }\n    },\n    equalTo(a, b, message) {\n        if (a !== b) {\n            throw new Error(message);\n        }\n    },\n};\n/**\n * Splits a `secret` into `shares` number of shares, requiring `threshold` of them to reconstruct `secret`.\n *\n * @param secret The secret value to split into shares.\n * @param shares The total number of shares to split `secret` into. Must be at least 2 and at most 255.\n * @param threshold The minimum number of shares required to reconstruct `secret`. Must be at least 2 and at most 255.\n * @returns A list of `shares` shares.\n */\nasync function split(secret, shares, threshold) {\n    // secret must be a non-empty Uint8Array\n    AssertArgument.instanceOf(secret, Uint8Array, 'secret must be a Uint8Array');\n    AssertArgument.greaterThanOrEqualTo(secret.byteLength, 1, 'secret cannot be empty');\n    // shares must be a number in the range [2, 256)\n    AssertArgument.instanceOf(shares, Number, 'shares must be a number');\n    AssertArgument.inRange(shares, 2, 256, 'shares must be at least 2 and at most 255');\n    // threshold must be a number in the range [2, 256)\n    AssertArgument.instanceOf(threshold, Number, 'threshold must be a number');\n    AssertArgument.inRange(threshold, 2, 256, 'threshold must be at least 2 and at most 255');\n    // total number of shares must be greater than or equal to the required threshold\n    AssertArgument.greaterThanOrEqualTo(shares, threshold, 'shares cannot be less than threshold');\n    const result = [];\n    const secretLength = secret.byteLength;\n    const xCoordinates = newCoordinates();\n    for (let i = 0; i < shares; i++) {\n        const share = new Uint8Array(secretLength + 1);\n        share[secretLength] = xCoordinates[i];\n        result.push(share);\n    }\n    const degree = threshold - 1;\n    for (let i = 0; i < secretLength; i++) {\n        const byte = secret[i];\n        const coefficients = newCoefficients(byte, degree);\n        for (let j = 0; j < shares; ++j) {\n            const x = xCoordinates[j];\n            const y = evaluate(coefficients, x, degree);\n            result[j][i] = y;\n        }\n    }\n    return result;\n}\n/**\n * Combines `shares` to reconstruct the secret.\n *\n * @param shares A list of shares to reconstruct the secret from. Must be at least 2 and at most 255.\n * @returns The reconstructed secret.\n */\nasync function combine(shares) {\n    // Shares must be an array with length in the range [2, 256)\n    AssertArgument.instanceOf(shares, Array, 'shares must be an Array');\n    AssertArgument.inRange(shares.length, 2, 256, 'shares must have at least 2 and at most 255 elements');\n    // Shares must be a Uint8Array with at least 2 bytes and all shares must have the same byte length.\n    const share1 = shares[0];\n    AssertArgument.instanceOf(share1, Uint8Array, 'each share must be a Uint8Array');\n    for (const share of shares) {\n        AssertArgument.instanceOf(share, Uint8Array, 'each share must be a Uint8Array');\n        AssertArgument.greaterThanOrEqualTo(share.byteLength, 2, 'each share must be at least 2 bytes');\n        AssertArgument.equalTo(share.byteLength, share1.byteLength, 'all shares must have the same byte length');\n    }\n    const sharesLength = shares.length;\n    const shareLength = share1.byteLength;\n    // This will be our reconstructed secret\n    const secretLength = shareLength - 1;\n    const secret = new Uint8Array(secretLength);\n    const xSamples = new Uint8Array(sharesLength);\n    const ySamples = new Uint8Array(sharesLength);\n    const samples = new Set();\n    for (let i = 0; i < sharesLength; i++) {\n        const share = shares[i];\n        const sample = share[shareLength - 1];\n        // The last byte of each share should be a unique value between 1-255 inclusive.\n        if (samples.has(sample)) {\n            throw new Error('shares must contain unique values but a duplicate was found');\n        }\n        samples.add(sample);\n        xSamples[i] = sample;\n    }\n    // Reconstruct each byte\n    for (let i = 0; i < secretLength; i++) {\n        // Set the y value for each sample\n        for (let j = 0; j < sharesLength; ++j) {\n            ySamples[j] = shares[j][i];\n        }\n        // Interpolate the polynomial and compute the value at 0\n        secret[i] = interpolatePolynomial(xSamples, ySamples, 0);\n    }\n    return secret;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2hhbWlyLXNlY3JldC1zaGFyaW5nL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEVBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRFQUFjO0FBQ3hDLG9CQUFvQixTQUFTO0FBQzdCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2hhbWlyLXNlY3JldC1zaGFyaW5nL2VzbS9pbmRleC5qcz9mY2NjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFJhbmRvbUJ5dGVzIH0gZnJvbSAnc2hhbWlyLXNlY3JldC1zaGFyaW5nL2NzcHJuZyc7XG4vLyBUaGUgUG9seW5vbWlhbCB1c2VkIGlzOiB44oG4ICsgeOKBtCArIHjCsyArIHggKyAxXG4vL1xuLy8gTG9va3VwIHRhYmxlcyBwdWxsZWQgZnJvbTpcbi8vXG4vLyAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vaGFzaGljb3JwL3ZhdWx0L2Jsb2IvOWQ0NjY3MTY1OWNiZmU3YmJkM2U3OGQxMDczZGZiMjI5MzZhNDQzNy9zaGFtaXIvdGFibGVzLmdvXG4vLyAgICAgKiBodHRwOi8vd3d3LnNhbWlhbS5vcmcvZ2Fsb2lzLmh0bWxcbi8vXG4vLyAweGU1ICgyMjkpIGlzIHVzZWQgYXMgdGhlIGdlbmVyYXRvci5cbi8vIFByb3ZpZGVzIGxvZyhYKS9sb2coZykgYXQgZWFjaCBpbmRleCBYLlxuY29uc3QgTE9HX1RBQkxFID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDB4MDAsIDB4ZmYsIDB4YzgsIDB4MDgsIDB4OTEsIDB4MTAsIDB4ZDAsIDB4MzYsIDB4NWEsIDB4M2UsIDB4ZDgsIDB4NDMsIDB4OTksIDB4NzcsIDB4ZmUsIDB4MTgsXG4gICAgMHgyMywgMHgyMCwgMHgwNywgMHg3MCwgMHhhMSwgMHg2YywgMHgwYywgMHg3ZiwgMHg2MiwgMHg4YiwgMHg0MCwgMHg0NiwgMHhjNywgMHg0YiwgMHhlMCwgMHgwZSxcbiAgICAweGViLCAweDE2LCAweGU4LCAweGFkLCAweGNmLCAweGNkLCAweDM5LCAweDUzLCAweDZhLCAweDI3LCAweDM1LCAweDkzLCAweGQ0LCAweDRlLCAweDQ4LCAweGMzLFxuICAgIDB4MmIsIDB4NzksIDB4NTQsIDB4MjgsIDB4MDksIDB4NzgsIDB4MGYsIDB4MjEsIDB4OTAsIDB4ODcsIDB4MTQsIDB4MmEsIDB4YTksIDB4OWMsIDB4ZDYsIDB4NzQsXG4gICAgMHhiNCwgMHg3YywgMHhkZSwgMHhlZCwgMHhiMSwgMHg4NiwgMHg3NiwgMHhhNCwgMHg5OCwgMHhlMiwgMHg5NiwgMHg4ZiwgMHgwMiwgMHgzMiwgMHgxYywgMHhjMSxcbiAgICAweDMzLCAweGVlLCAweGVmLCAweDgxLCAweGZkLCAweDMwLCAweDVjLCAweDEzLCAweDlkLCAweDI5LCAweDE3LCAweGM0LCAweDExLCAweDQ0LCAweDhjLCAweDgwLFxuICAgIDB4ZjMsIDB4NzMsIDB4NDIsIDB4MWUsIDB4MWQsIDB4YjUsIDB4ZjAsIDB4MTIsIDB4ZDEsIDB4NWIsIDB4NDEsIDB4YTIsIDB4ZDcsIDB4MmMsIDB4ZTksIDB4ZDUsXG4gICAgMHg1OSwgMHhjYiwgMHg1MCwgMHhhOCwgMHhkYywgMHhmYywgMHhmMiwgMHg1NiwgMHg3MiwgMHhhNiwgMHg2NSwgMHgyZiwgMHg5ZiwgMHg5YiwgMHgzZCwgMHhiYSxcbiAgICAweDdkLCAweGMyLCAweDQ1LCAweDgyLCAweGE3LCAweDU3LCAweGI2LCAweGEzLCAweDdhLCAweDc1LCAweDRmLCAweGFlLCAweDNmLCAweDM3LCAweDZkLCAweDQ3LFxuICAgIDB4NjEsIDB4YmUsIDB4YWIsIDB4ZDMsIDB4NWYsIDB4YjAsIDB4NTgsIDB4YWYsIDB4Y2EsIDB4NWUsIDB4ZmEsIDB4ODUsIDB4ZTQsIDB4NGQsIDB4OGEsIDB4MDUsXG4gICAgMHhmYiwgMHg2MCwgMHhiNywgMHg3YiwgMHhiOCwgMHgyNiwgMHg0YSwgMHg2NywgMHhjNiwgMHgxYSwgMHhmOCwgMHg2OSwgMHgyNSwgMHhiMywgMHhkYiwgMHhiZCxcbiAgICAweDY2LCAweGRkLCAweGYxLCAweGQyLCAweGRmLCAweDAzLCAweDhkLCAweDM0LCAweGQ5LCAweDkyLCAweDBkLCAweDYzLCAweDU1LCAweGFhLCAweDQ5LCAweGVjLFxuICAgIDB4YmMsIDB4OTUsIDB4M2MsIDB4ODQsIDB4MGIsIDB4ZjUsIDB4ZTYsIDB4ZTcsIDB4ZTUsIDB4YWMsIDB4N2UsIDB4NmUsIDB4YjksIDB4ZjksIDB4ZGEsIDB4OGUsXG4gICAgMHg5YSwgMHhjOSwgMHgyNCwgMHhlMSwgMHgwYSwgMHgxNSwgMHg2YiwgMHgzYSwgMHhhMCwgMHg1MSwgMHhmNCwgMHhlYSwgMHhiMiwgMHg5NywgMHg5ZSwgMHg1ZCxcbiAgICAweDIyLCAweDg4LCAweDk0LCAweGNlLCAweDE5LCAweDAxLCAweDcxLCAweDRjLCAweGE1LCAweGUzLCAweGM1LCAweDMxLCAweGJiLCAweGNjLCAweDFmLCAweDJkLFxuICAgIDB4M2IsIDB4NTIsIDB4NmYsIDB4ZjYsIDB4MmUsIDB4ODksIDB4ZjcsIDB4YzAsIDB4NjgsIDB4MWIsIDB4NjQsIDB4MDQsIDB4MDYsIDB4YmYsIDB4ODMsIDB4MzgsXG5dKTtcbi8vIFByb3ZpZGVzIHRoZSBleHBvbmVudGlhdGlvbiB2YWx1ZSBhdCBlYWNoIGluZGV4IFguXG5jb25zdCBFWFBfVEFCTEUgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMSwgMHhlNSwgMHg0YywgMHhiNSwgMHhmYiwgMHg5ZiwgMHhmYywgMHgxMiwgMHgwMywgMHgzNCwgMHhkNCwgMHhjNCwgMHgxNiwgMHhiYSwgMHgxZiwgMHgzNixcbiAgICAweDA1LCAweDVjLCAweDY3LCAweDU3LCAweDNhLCAweGQ1LCAweDIxLCAweDVhLCAweDBmLCAweGU0LCAweGE5LCAweGY5LCAweDRlLCAweDY0LCAweDYzLCAweGVlLFxuICAgIDB4MTEsIDB4MzcsIDB4ZTAsIDB4MTAsIDB4ZDIsIDB4YWMsIDB4YTUsIDB4MjksIDB4MzMsIDB4NTksIDB4M2IsIDB4MzAsIDB4NmQsIDB4ZWYsIDB4ZjQsIDB4N2IsXG4gICAgMHg1NSwgMHhlYiwgMHg0ZCwgMHg1MCwgMHhiNywgMHgyYSwgMHgwNywgMHg4ZCwgMHhmZiwgMHgyNiwgMHhkNywgMHhmMCwgMHhjMiwgMHg3ZSwgMHgwOSwgMHg4YyxcbiAgICAweDFhLCAweDZhLCAweDYyLCAweDBiLCAweDVkLCAweDgyLCAweDFiLCAweDhmLCAweDJlLCAweGJlLCAweGE2LCAweDFkLCAweGU3LCAweDlkLCAweDJkLCAweDhhLFxuICAgIDB4NzIsIDB4ZDksIDB4ZjEsIDB4MjcsIDB4MzIsIDB4YmMsIDB4NzcsIDB4ODUsIDB4OTYsIDB4NzAsIDB4MDgsIDB4NjksIDB4NTYsIDB4ZGYsIDB4OTksIDB4OTQsXG4gICAgMHhhMSwgMHg5MCwgMHgxOCwgMHhiYiwgMHhmYSwgMHg3YSwgMHhiMCwgMHhhNywgMHhmOCwgMHhhYiwgMHgyOCwgMHhkNiwgMHgxNSwgMHg4ZSwgMHhjYiwgMHhmMixcbiAgICAweDEzLCAweGU2LCAweDc4LCAweDYxLCAweDNmLCAweDg5LCAweDQ2LCAweDBkLCAweDM1LCAweDMxLCAweDg4LCAweGEzLCAweDQxLCAweDgwLCAweGNhLCAweDE3LFxuICAgIDB4NWYsIDB4NTMsIDB4ODMsIDB4ZmUsIDB4YzMsIDB4OWIsIDB4NDUsIDB4MzksIDB4ZTEsIDB4ZjUsIDB4OWUsIDB4MTksIDB4NWUsIDB4YjYsIDB4Y2YsIDB4NGIsXG4gICAgMHgzOCwgMHgwNCwgMHhiOSwgMHgyYiwgMHhlMiwgMHhjMSwgMHg0YSwgMHhkZCwgMHg0OCwgMHgwYywgMHhkMCwgMHg3ZCwgMHgzZCwgMHg1OCwgMHhkZSwgMHg3YyxcbiAgICAweGQ4LCAweDE0LCAweDZiLCAweDg3LCAweDQ3LCAweGU4LCAweDc5LCAweDg0LCAweDczLCAweDNjLCAweGJkLCAweDkyLCAweGM5LCAweDIzLCAweDhiLCAweDk3LFxuICAgIDB4OTUsIDB4NDQsIDB4ZGMsIDB4YWQsIDB4NDAsIDB4NjUsIDB4ODYsIDB4YTIsIDB4YTQsIDB4Y2MsIDB4N2YsIDB4ZWMsIDB4YzAsIDB4YWYsIDB4OTEsIDB4ZmQsXG4gICAgMHhmNywgMHg0ZiwgMHg4MSwgMHgyZiwgMHg1YiwgMHhlYSwgMHhhOCwgMHgxYywgMHgwMiwgMHhkMSwgMHg5OCwgMHg3MSwgMHhlZCwgMHgyNSwgMHhlMywgMHgyNCxcbiAgICAweDA2LCAweDY4LCAweGIzLCAweDkzLCAweDJjLCAweDZmLCAweDNlLCAweDZjLCAweDBhLCAweGI4LCAweGNlLCAweGFlLCAweDc0LCAweGIxLCAweDQyLCAweGI0LFxuICAgIDB4MWUsIDB4ZDMsIDB4NDksIDB4ZTksIDB4OWMsIDB4YzgsIDB4YzYsIDB4YzcsIDB4MjIsIDB4NmUsIDB4ZGIsIDB4MjAsIDB4YmYsIDB4NDMsIDB4NTEsIDB4NTIsXG4gICAgMHg2NiwgMHhiMiwgMHg3NiwgMHg2MCwgMHhkYSwgMHhjNSwgMHhmMywgMHhmNiwgMHhhYSwgMHhjZCwgMHg5YSwgMHhhMCwgMHg3NSwgMHg1NCwgMHgwZSwgMHgwMSxcbl0pO1xuLy8gQ29tYmluZXMgdHdvIG51bWJlcnMgaW4gR0YoMl44KS5cbi8vIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGJvdGggYWRkaXRpb24gYW5kIHN1YnRyYWN0aW9uLlxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYSkgfHwgYSA8IDAgfHwgYSA+IDI1NSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTnVtYmVyIGlzIG91dCBvZiBVaW50OCByYW5nZScpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYikgfHwgYiA8IDAgfHwgYiA+IDI1NSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTnVtYmVyIGlzIG91dCBvZiBVaW50OCByYW5nZScpO1xuICAgIH1cbiAgICByZXR1cm4gYSBeIGI7XG59XG4vLyBEaXZpZGVzIHR3byBudW1iZXJzIGluIEdGKDJeOCkuXG5mdW5jdGlvbiBkaXYoYSwgYikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhKSB8fCBhIDwgMCB8fCBhID4gMjU1KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIgaXMgb3V0IG9mIFVpbnQ4IHJhbmdlJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihiKSB8fCBiIDwgMCB8fCBiID4gMjU1KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIgaXMgb3V0IG9mIFVpbnQ4IHJhbmdlJyk7XG4gICAgfVxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGRpdmlkZSBieSB6ZXJvJyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0EgPSBMT0dfVEFCTEVbYV07XG4gICAgY29uc3QgbG9nQiA9IExPR19UQUJMRVtiXTtcbiAgICBjb25zdCBkaWZmID0gKGxvZ0EgLSBsb2dCICsgMjU1KSAlIDI1NTtcbiAgICBjb25zdCByZXN1bHQgPSBFWFBfVEFCTEVbZGlmZl07XG4gICAgcmV0dXJuIGEgPT09IDAgPyAwIDogcmVzdWx0O1xufVxuLy8gTXVsdGlwbGllcyB0d28gbnVtYmVycyBpbiBHRigyXjgpLlxuZnVuY3Rpb24gbXVsdChhLCBiKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGEpIHx8IGEgPCAwIHx8IGEgPiAyNTUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ051bWJlciBpcyBvdXQgb2YgVWludDggcmFuZ2UnKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ051bWJlciBpcyBvdXQgb2YgVWludDggcmFuZ2UnKTtcbiAgICB9XG4gICAgY29uc3QgbG9nQSA9IExPR19UQUJMRVthXTtcbiAgICBjb25zdCBsb2dCID0gTE9HX1RBQkxFW2JdO1xuICAgIGNvbnN0IHN1bSA9IChsb2dBICsgbG9nQikgJSAyNTU7XG4gICAgY29uc3QgcmVzdWx0ID0gRVhQX1RBQkxFW3N1bV07XG4gICAgcmV0dXJuIGEgPT09IDAgfHwgYiA9PT0gMCA/IDAgOiByZXN1bHQ7XG59XG4vLyBUYWtlcyBOIHNhbXBsZSBwb2ludHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIGF0IGEgZ2l2ZW4geCB1c2luZyBhIGxhZ3JhbmdlIGludGVycG9sYXRpb24uXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVBvbHlub21pYWwoeFNhbXBsZXMsIHlTYW1wbGVzLCB4KSB7XG4gICAgaWYgKHhTYW1wbGVzLmxlbmd0aCAhPT0geVNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2FtcGxlIGxlbmd0aCBtaXN0bWF0Y2gnKTtcbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB4U2FtcGxlcy5sZW5ndGg7XG4gICAgbGV0IGJhc2lzID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgYmFzaXMgPSAxO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBudW0gPSBhZGQoeCwgeFNhbXBsZXNbal0pO1xuICAgICAgICAgICAgY29uc3QgZGVub20gPSBhZGQoeFNhbXBsZXNbaV0sIHhTYW1wbGVzW2pdKTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBkaXYobnVtLCBkZW5vbSk7XG4gICAgICAgICAgICBiYXNpcyA9IG11bHQoYmFzaXMsIHRlcm0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGFkZChyZXN1bHQsIG11bHQoeVNhbXBsZXNbaV0sIGJhc2lzKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBFdmFsdWF0ZXMgYSBwb2x5bm9taWFsIHdpdGggdGhlIGdpdmVuIHggdXNpbmcgSG9ybmVyJ3MgbWV0aG9kLlxuZnVuY3Rpb24gZXZhbHVhdGUoY29lZmZpY2llbnRzLCB4LCBkZWdyZWUpIHtcbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBldmFsdWF0ZSBzZWNyZXQgcG9seW5vbWlhbCBhdCB6ZXJvJyk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBjb2VmZmljaWVudHNbZGVncmVlXTtcbiAgICBmb3IgKGxldCBpID0gZGVncmVlIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudHNbaV07XG4gICAgICAgIHJlc3VsdCA9IGFkZChtdWx0KHJlc3VsdCwgeCksIGNvZWZmaWNpZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGUoKSB7XG4gICAgcmV0dXJuIGdldFJhbmRvbUJ5dGVzKDEpWzBdO1xufVxuZnVuY3Rpb24gZ2V0Tm9uWmVyb1JhbmRvbUJ5dGUoKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGdldFJhbmRvbUJ5dGUoKTtcbiAgICAgICAgaWYgKGJ5dGUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENyZWF0ZXMgYSBwc2V1ZG8tcmFuZG9tIHNldCBvZiBjb2VmZmljaWVudHMgZm9yIGEgcG9seW5vbWlhbC5cbmZ1bmN0aW9uIG5ld0NvZWZmaWNpZW50cyhpbnRlcmNlcHQsIGRlZ3JlZSkge1xuICAgIGNvbnN0IGNvZWZmaWNpZW50cyA9IG5ldyBVaW50OEFycmF5KGRlZ3JlZSArIDEpO1xuICAgIC8vIFRoZSBmaXJzdCBieXRlIGlzIGFsd2F5cyB0aGUgaW50ZXJjZXB0XG4gICAgY29lZmZpY2llbnRzWzBdID0gaW50ZXJjZXB0O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XG4gICAgICAgIC8vIGRlZ3JlZSBpcyBlcXVhbCB0byB0LTEsIHdoZXJlIHQgaXMgdGhlIHRocmVzaG9sZCBvZiByZXF1aXJlZCBzaGFyZXMuXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudCBhdCB0LTEgY2Fubm90IGVxdWFsIDAuXG4gICAgICAgIGNvbnN0IGNvZWZmaWNpZW50VE1pbnVzMSA9IGkgPT09IGRlZ3JlZTtcbiAgICAgICAgY29lZmZpY2llbnRzW2ldID0gY29lZmZpY2llbnRUTWludXMxID8gZ2V0Tm9uWmVyb1JhbmRvbUJ5dGUoKSA6IGdldFJhbmRvbUJ5dGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZWZmaWNpZW50cztcbn1cbi8vIENyZWF0ZXMgYSBzZXQgb2YgdmFsdWVzIGZyb20gWzEsIDI1NikuXG4vLyBSZXR1cm5zIGEgcHN1ZWRvLXJhbmRvbSBzaHVmZmxpbmcgb2YgdGhlIHNldC5cbmZ1bmN0aW9uIG5ld0Nvb3JkaW5hdGVzKCkge1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gbmV3IFVpbnQ4QXJyYXkoMjU1KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzW2ldID0gaSArIDE7XG4gICAgfVxuICAgIC8vIFBzZXVkby1yYW5kb21pemUgdGhlIGFycmF5IG9mIGNvb3JkaW5hdGVzLlxuICAgIC8vXG4gICAgLy8gVGhpcyBpbXBsIG1hcHMgYWxtb3N0IHBlcmZlY3RseSBiZWNhdXNlIGJvdGggb2YgdGhlIGxpc3RzIChjb29yZGluYXRlcyBhbmQgcmFuZG9tSW5kaWNlcylcbiAgICAvLyBoYXZlIGEgbGVuZ3RoIG9mIDI1NSBhbmQgYnl0ZSB2YWx1ZXMgYXJlIGJldHdlZW4gMCBhbmQgMjU1IGluY2x1c2l2ZS4gVGhlIG9ubHkgdmFsdWUgdGhhdFxuICAgIC8vIGRvZXMgbm90IG1hcCBuZWF0bHkgaGVyZSBpcyBpZiB0aGUgcmFuZG9tIGJ5dGUgaXMgMjU1LCBzaW5jZSB0aGF0IHZhbHVlIHVzZWQgYXMgYW4gaW5kZXhcbiAgICAvLyB3b3VsZCBiZSBvdXQgb2YgYm91bmRzLiBUaHVzLCBmb3IgYnl0ZXMgd2hvc2UgdmFsdWUgaXMgMjU1LCB3cmFwIGFyb3VuZCB0byAwLlxuICAgIGNvbnN0IHJhbmRvbUluZGljZXMgPSBnZXRSYW5kb21CeXRlcygyNTUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IHJhbmRvbUluZGljZXNbaV0gJSAyNTU7IC8vIE1ha2Ugc3VyZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGJ5dGUgaXMgMjU1LlxuICAgICAgICBjb25zdCB0ZW1wID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGNvb3JkaW5hdGVzW2ldID0gY29vcmRpbmF0ZXNbal07XG4gICAgICAgIGNvb3JkaW5hdGVzW2pdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuLy8gSGVscGVycyBmb3IgZGVjbGFyYXRpdmUgYXJndW1lbnQgdmFsaWRhdGlvbi5cbmNvbnN0IEFzc2VydEFyZ3VtZW50ID0ge1xuICAgIGluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgbWVzc2FnZSkge1xuICAgICAgICBpZiAob2JqZWN0LmNvbnN0cnVjdG9yICE9PSBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaW5SYW5nZShuLCBzdGFydCwgdW50aWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCEoc3RhcnQgPCB1bnRpbCAmJiBuID49IHN0YXJ0ICYmIG4gPCB1bnRpbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBncmVhdGVyVGhhbk9yRXF1YWxUbyhhLCBiLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlcXVhbFRvKGEsIGIsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuLyoqXG4gKiBTcGxpdHMgYSBgc2VjcmV0YCBpbnRvIGBzaGFyZXNgIG51bWJlciBvZiBzaGFyZXMsIHJlcXVpcmluZyBgdGhyZXNob2xkYCBvZiB0aGVtIHRvIHJlY29uc3RydWN0IGBzZWNyZXRgLlxuICpcbiAqIEBwYXJhbSBzZWNyZXQgVGhlIHNlY3JldCB2YWx1ZSB0byBzcGxpdCBpbnRvIHNoYXJlcy5cbiAqIEBwYXJhbSBzaGFyZXMgVGhlIHRvdGFsIG51bWJlciBvZiBzaGFyZXMgdG8gc3BsaXQgYHNlY3JldGAgaW50by4gTXVzdCBiZSBhdCBsZWFzdCAyIGFuZCBhdCBtb3N0IDI1NS5cbiAqIEBwYXJhbSB0aHJlc2hvbGQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIHNoYXJlcyByZXF1aXJlZCB0byByZWNvbnN0cnVjdCBgc2VjcmV0YC4gTXVzdCBiZSBhdCBsZWFzdCAyIGFuZCBhdCBtb3N0IDI1NS5cbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBgc2hhcmVzYCBzaGFyZXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzcGxpdChzZWNyZXQsIHNoYXJlcywgdGhyZXNob2xkKSB7XG4gICAgLy8gc2VjcmV0IG11c3QgYmUgYSBub24tZW1wdHkgVWludDhBcnJheVxuICAgIEFzc2VydEFyZ3VtZW50Lmluc3RhbmNlT2Yoc2VjcmV0LCBVaW50OEFycmF5LCAnc2VjcmV0IG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgQXNzZXJ0QXJndW1lbnQuZ3JlYXRlclRoYW5PckVxdWFsVG8oc2VjcmV0LmJ5dGVMZW5ndGgsIDEsICdzZWNyZXQgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgLy8gc2hhcmVzIG11c3QgYmUgYSBudW1iZXIgaW4gdGhlIHJhbmdlIFsyLCAyNTYpXG4gICAgQXNzZXJ0QXJndW1lbnQuaW5zdGFuY2VPZihzaGFyZXMsIE51bWJlciwgJ3NoYXJlcyBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgQXNzZXJ0QXJndW1lbnQuaW5SYW5nZShzaGFyZXMsIDIsIDI1NiwgJ3NoYXJlcyBtdXN0IGJlIGF0IGxlYXN0IDIgYW5kIGF0IG1vc3QgMjU1Jyk7XG4gICAgLy8gdGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIgaW4gdGhlIHJhbmdlIFsyLCAyNTYpXG4gICAgQXNzZXJ0QXJndW1lbnQuaW5zdGFuY2VPZih0aHJlc2hvbGQsIE51bWJlciwgJ3RocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgQXNzZXJ0QXJndW1lbnQuaW5SYW5nZSh0aHJlc2hvbGQsIDIsIDI1NiwgJ3RocmVzaG9sZCBtdXN0IGJlIGF0IGxlYXN0IDIgYW5kIGF0IG1vc3QgMjU1Jyk7XG4gICAgLy8gdG90YWwgbnVtYmVyIG9mIHNoYXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWQgdGhyZXNob2xkXG4gICAgQXNzZXJ0QXJndW1lbnQuZ3JlYXRlclRoYW5PckVxdWFsVG8oc2hhcmVzLCB0aHJlc2hvbGQsICdzaGFyZXMgY2Fubm90IGJlIGxlc3MgdGhhbiB0aHJlc2hvbGQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzZWNyZXRMZW5ndGggPSBzZWNyZXQuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCB4Q29vcmRpbmF0ZXMgPSBuZXdDb29yZGluYXRlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcmVzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2hhcmUgPSBuZXcgVWludDhBcnJheShzZWNyZXRMZW5ndGggKyAxKTtcbiAgICAgICAgc2hhcmVbc2VjcmV0TGVuZ3RoXSA9IHhDb29yZGluYXRlc1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2goc2hhcmUpO1xuICAgIH1cbiAgICBjb25zdCBkZWdyZWUgPSB0aHJlc2hvbGQgLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjcmV0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IHNlY3JldFtpXTtcbiAgICAgICAgY29uc3QgY29lZmZpY2llbnRzID0gbmV3Q29lZmZpY2llbnRzKGJ5dGUsIGRlZ3JlZSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2hhcmVzOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB4Q29vcmRpbmF0ZXNbal07XG4gICAgICAgICAgICBjb25zdCB5ID0gZXZhbHVhdGUoY29lZmZpY2llbnRzLCB4LCBkZWdyZWUpO1xuICAgICAgICAgICAgcmVzdWx0W2pdW2ldID0geTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb21iaW5lcyBgc2hhcmVzYCB0byByZWNvbnN0cnVjdCB0aGUgc2VjcmV0LlxuICpcbiAqIEBwYXJhbSBzaGFyZXMgQSBsaXN0IG9mIHNoYXJlcyB0byByZWNvbnN0cnVjdCB0aGUgc2VjcmV0IGZyb20uIE11c3QgYmUgYXQgbGVhc3QgMiBhbmQgYXQgbW9zdCAyNTUuXG4gKiBAcmV0dXJucyBUaGUgcmVjb25zdHJ1Y3RlZCBzZWNyZXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21iaW5lKHNoYXJlcykge1xuICAgIC8vIFNoYXJlcyBtdXN0IGJlIGFuIGFycmF5IHdpdGggbGVuZ3RoIGluIHRoZSByYW5nZSBbMiwgMjU2KVxuICAgIEFzc2VydEFyZ3VtZW50Lmluc3RhbmNlT2Yoc2hhcmVzLCBBcnJheSwgJ3NoYXJlcyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgQXNzZXJ0QXJndW1lbnQuaW5SYW5nZShzaGFyZXMubGVuZ3RoLCAyLCAyNTYsICdzaGFyZXMgbXVzdCBoYXZlIGF0IGxlYXN0IDIgYW5kIGF0IG1vc3QgMjU1IGVsZW1lbnRzJyk7XG4gICAgLy8gU2hhcmVzIG11c3QgYmUgYSBVaW50OEFycmF5IHdpdGggYXQgbGVhc3QgMiBieXRlcyBhbmQgYWxsIHNoYXJlcyBtdXN0IGhhdmUgdGhlIHNhbWUgYnl0ZSBsZW5ndGguXG4gICAgY29uc3Qgc2hhcmUxID0gc2hhcmVzWzBdO1xuICAgIEFzc2VydEFyZ3VtZW50Lmluc3RhbmNlT2Yoc2hhcmUxLCBVaW50OEFycmF5LCAnZWFjaCBzaGFyZSBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgIGZvciAoY29uc3Qgc2hhcmUgb2Ygc2hhcmVzKSB7XG4gICAgICAgIEFzc2VydEFyZ3VtZW50Lmluc3RhbmNlT2Yoc2hhcmUsIFVpbnQ4QXJyYXksICdlYWNoIHNoYXJlIG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgICAgIEFzc2VydEFyZ3VtZW50LmdyZWF0ZXJUaGFuT3JFcXVhbFRvKHNoYXJlLmJ5dGVMZW5ndGgsIDIsICdlYWNoIHNoYXJlIG11c3QgYmUgYXQgbGVhc3QgMiBieXRlcycpO1xuICAgICAgICBBc3NlcnRBcmd1bWVudC5lcXVhbFRvKHNoYXJlLmJ5dGVMZW5ndGgsIHNoYXJlMS5ieXRlTGVuZ3RoLCAnYWxsIHNoYXJlcyBtdXN0IGhhdmUgdGhlIHNhbWUgYnl0ZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3Qgc2hhcmVzTGVuZ3RoID0gc2hhcmVzLmxlbmd0aDtcbiAgICBjb25zdCBzaGFyZUxlbmd0aCA9IHNoYXJlMS5ieXRlTGVuZ3RoO1xuICAgIC8vIFRoaXMgd2lsbCBiZSBvdXIgcmVjb25zdHJ1Y3RlZCBzZWNyZXRcbiAgICBjb25zdCBzZWNyZXRMZW5ndGggPSBzaGFyZUxlbmd0aCAtIDE7XG4gICAgY29uc3Qgc2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoc2VjcmV0TGVuZ3RoKTtcbiAgICBjb25zdCB4U2FtcGxlcyA9IG5ldyBVaW50OEFycmF5KHNoYXJlc0xlbmd0aCk7XG4gICAgY29uc3QgeVNhbXBsZXMgPSBuZXcgVWludDhBcnJheShzaGFyZXNMZW5ndGgpO1xuICAgIGNvbnN0IHNhbXBsZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFyZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaGFyZSA9IHNoYXJlc1tpXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gc2hhcmVbc2hhcmVMZW5ndGggLSAxXTtcbiAgICAgICAgLy8gVGhlIGxhc3QgYnl0ZSBvZiBlYWNoIHNoYXJlIHNob3VsZCBiZSBhIHVuaXF1ZSB2YWx1ZSBiZXR3ZWVuIDEtMjU1IGluY2x1c2l2ZS5cbiAgICAgICAgaWYgKHNhbXBsZXMuaGFzKHNhbXBsZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmVzIG11c3QgY29udGFpbiB1bmlxdWUgdmFsdWVzIGJ1dCBhIGR1cGxpY2F0ZSB3YXMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBzYW1wbGVzLmFkZChzYW1wbGUpO1xuICAgICAgICB4U2FtcGxlc1tpXSA9IHNhbXBsZTtcbiAgICB9XG4gICAgLy8gUmVjb25zdHJ1Y3QgZWFjaCBieXRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWNyZXRMZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTZXQgdGhlIHkgdmFsdWUgZm9yIGVhY2ggc2FtcGxlXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2hhcmVzTGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHlTYW1wbGVzW2pdID0gc2hhcmVzW2pdW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludGVycG9sYXRlIHRoZSBwb2x5bm9taWFsIGFuZCBjb21wdXRlIHRoZSB2YWx1ZSBhdCAwXG4gICAgICAgIHNlY3JldFtpXSA9IGludGVycG9sYXRlUG9seW5vbWlhbCh4U2FtcGxlcywgeVNhbXBsZXMsIDApO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcmV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/shamir-secret-sharing/esm/index.js\n");

/***/ })

};
;